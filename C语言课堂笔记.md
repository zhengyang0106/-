# C语言课堂笔记   

​                                                  --- 抽象化程度越高，执行效率越低，开发率越高

##### 输入输出

+ **printf**

  + 原型  int  printf (const char * format,  ...)

    + format  -->格式控制字符串
    + ...   -- > 可变参数列表
    + 返回值 为： 输出字符个数

  + sprintf(str, "% ", n);

    通过字符串向 n 输入

  + fprintf(fp ," % ")

#####  数的运算

+ **函数**

  | 函数                                               | 功能           | 库       |
  | -------------------------------------------------- | -------------- | -------- |
  | ceil(n)                                            | 上取整         | math.h   |
  | flower(n)                                          | 下取整         | math.h   |
  | abs                                                | 整数绝对值     | stdlib.h |
  | fabs                                               | 浮点数取绝对值 | math.h   |
  | acos(n)   n　为角度值　　返回值为弧度              | 反余弦函数     | math.h   |
  | sin(n)  　n　为弧度值　　返回值为角度值            | 正弦函数       | math.h   |
  | pow(a,n)    给ａ的ｎ次方同理　ｎ< 1 为　开几次方根 | n 次方/ 根     | math.h   |
  | log10（ｎ）  可以用于输出十进制下　ｎ的位数        | ｌｏｇ１０     | math.h   |

+ **＃include<inttypes\>**

  + int64_t   n ;   ----\> 定义一个64为整型变量　　相当于　long long  n;   
    + 输出　用　printf("%" PRId64, ...); d 表示十进制　　ＰＲＩ相当于　ｌｌ
  + 使用　
  + int64_t  可以保证代码的可移植性　　保证了不同系统下　long long 定义的字节数
  + IN64_MAX  ---\> 极大整数
  + IN64_MIN ---  \> 极小数

+ **位运算**

  + ~  取反　　

    + while(~sacnf(" %d",....)){...}   ==  while(scanf("%d ", ...   ) !＝ EOF){...}

      是因为每个文件的末尾都有一个标志　　ＥＯＦ　　他的值为－１　

      ~（-1） == 0   所以可以终止循环

  + = 

    + 等号的　左值右值是按照　是否能在下一行出现确定的　　不是　按照左右位置区分

  + ^  异或符

    * if  a^ b=c   则　　b^ c=a     a^c=b  同为：０　异为：１
    * 把数字变为字符   ：   x = 5;  char a;  a = x ^ 48 ;  --- \>   48 就是 字符 '0’ 的 ASCII 值

  + & 按位与　　

    + １＆１　为１　　　像乘法　

  + \| 按位或　　有１　为１ 　　　像加法

  + <<　　 -->左移运算符 相当于× 2  末尾 补 0

  + \>> 　　--> 右移运算符  相当于 /  2  首位补   符号位   （-1   \>>   -1）  正数右移最小是 0  负数最大是 -1

  + f(a) = !!(a)   --->归一化　　　任何数进来都会变为　１

  + i == 0 || printf ("  ");   printf ("%i",i);    // 此句　用于输出控制　空格

  + ###### cent  += 1   <==>   cent += (val % 2 == 0)   <==>  cent  += (!  val % 2)   <== >  cent  += (  ! (value & 1))

  + ###### val & 3 = val % 4     ==>   (val & (2 ^ i -1) ) == vai % 2 ^ i 

+ **函数**
  + 递归
    1. 定义递归函数明确的语义
    2. 边界条件处理
    3. 问题出处理过程　和　递归过程
    4. 返回结果
  + 变参函数
    + <srdarg.h> 头文件
    + va_list 类型　　参数指针类型　　用于定义　一个可变参数指针　ej : va_list  arg;
    + va_start(arg, n) 函数　用于初始化一个　arg 参数指针；　并传入参数列表的　最后一个参数名
    + va_arg(arg, int) 函数　　用于　取出一个参数列表中的　　int 型　参数值；
    + va_copy(va_list a,  arg);  　　用于初始化　ａ　　用arg 　初始化a;

+ **格式化字符串**

  + 格式占位符  %[parameter] [flags] [field width] [ . precision] [length] type

    + parameter  

      n$  表示是第几个参数  如果使用 必须所有参数都使用

      `printf("%2$d %2$#x; %1$d %1$#x",16,17)` 产生"`17 0x11; 16 0x10`"

    + flags 

      | 字符 |                                                              |
      | :--- | ------------------------------------------------------------ |
      | +    | 表示有符号数的 ‘+’  ‘-’  缺省表示整数 ，仅适用于数值类型     |
      | 空格 | 使得有符号数的输出如果没有正负号 或者 输出 0个字符 前缀一个空格 。与 + 同时出现时 忽略 空格的 存在 |
      | -    | 左对齐                                                       |
      | #    | 对于g G  不删除尾部0 表示精度，对于 f F e E g G，总是输出小数点。 对于 o x X 在非0 数值前输出 0 ，0x ，0X，表示进制 |
      | 0    | 如果width 选项前缀 0 ，则在左侧用0 填充达到宽度  。 与 - 号出现时被忽略 |

    + Field width 

      输出宽度值  不足宽度用 0  或 空格 补充 ，超出则宽度并补截断输出 ，显示全部。 如果宽度值 为 *   ，表示由函数参数的值作为当前宽度

    + precision 

      通常指明输出的*最大*长度，依赖于特定的格式化类型。对于d、i、u、x、o的整型数值，是指最小数字位数，不足的位要在左侧补0，如果超过也不截断，缺省值为1。对于a,A,e,E,f,F的浮点数值，是指小数点右边显示的数字位数，必要时四舍五入或补0；缺省值为6。对于g,G的浮点数值，是指[有效数字](https://www.bk.gugeeseo.com/baike-%E6%9C%89%E6%95%88%E6%95%B0%E5%AD%97)的最大位数；缺省值为6。对于s的字符串类型，是指输出的字节的上限，超出限制的其它字符将被截断。如果域宽为`*`，则由对应的函数参数的值为当前域宽。如果仅给出了小数点，则域宽为0

    + length  

      指出浮点型或者整形参数的长度 

+ 

